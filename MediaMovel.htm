<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador: Filtro de Média Móvel</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
        }
        h1 { margin-top: 0; }
        .controls {
            background: #fff;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #canvas-container {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 10px;
            position: relative;
        }
        canvas {
            display: block;
            background-color: #fafafa;
            border: 1px solid #ddd;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 14px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .color-box { width: 15px; height: 15px; border-radius: 3px; }
    </style>
</head>
<body>

    <h1>Filtro de Média Móvel Simples</h1>
    
    <div class="controls">
        <div class="control-group">
            <label for="m-value">Tamanho da Janela (M): <b><span id="m-display">5</span></b></label>
            <input type="range" id="m-value" min="2" max="30" value="5" oninput="document.getElementById('m-display').innerText = this.value">
        </div>
        <div class="control-group">
            <label for="speed">Velocidade da Animação:</label>
            <input type="range" id="speed" min="10" max="500" value="100" dir="rtl"> </div>
        <button id="btn-start">Aplicar Média Móvel</button>
        <button id="btn-reset">Novo Sinal</button>
    </div>

    <div id="canvas-container">
        <canvas id="simCanvas" width="800" height="400"></canvas>
        <div class="legend">
            <div class="legend-item"><div class="color-box" style="background: #a0c4ff;"></div> Sinal Original (Ruidoso)</div>
            <div class="legend-item"><div class="color-box" style="background: rgba(255, 193, 7, 0.4);"></div> Janela Atual (M)</div>
            <div class="legend-item"><div class="color-box" style="background: #ff0000;"></div> Sinal Filtrado (Média)</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const btnStart = document.getElementById('btn-start');
        const btnReset = document.getElementById('btn-reset');
        const mInput = document.getElementById('m-value');
        const speedInput = document.getElementById('speed');

        const N = 150; // Número de pontos
        let originalSignal = [];
        let filteredSignal = [];
        
        let isAnimating = false;
        let currentStep = 0;
        let animationTimer = null;

        // Configurações de desenho
        const margin = 40;
        const width = canvas.width - 2 * margin;
        const height = canvas.height - 2 * margin;

        function generateData() {
            originalSignal = [];
            filteredSignal = new Array(N).fill(null);
            
            // Frequência da senoide
            const freq = 4 * Math.PI / N; 
            
            for (let i = 0; i < N; i++) {
                // Senoide pura + Ruído Branco (valores aleatórios entre -0.5 e 0.5 ajustados por um fator)
                let sine = Math.sin(i * freq);
                let noise = (Math.random() - 0.5) * 1.2;
                originalSignal.push(sine + noise);
            }
        }

        // Converte valor de índice X e valor Y para coordenadas do canvas
        function getX(i) { return margin + (i / (N - 1)) * width; }
        function getY(val) { 
            // Os valores variam aproximadamente de -2 a +2. 
            // Mapeando para a altura do canvas (y cresce para baixo)
            return margin + height / 2 - (val * (height / 4)); 
        }

        function drawBase() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Desenhar eixos
            ctx.beginPath();
            ctx.moveTo(margin, margin + height/2);
            ctx.lineTo(canvas.width - margin, margin + height/2);
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Desenhar sinal original
            ctx.beginPath();
            for (let i = 0; i < N; i++) {
                let x = getX(i);
                let y = getY(originalSignal[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.strokeStyle = '#a0c4ff'; // Azul claro
            ctx.lineWidth = 2;
            ctx.stroke();

            // Desenhar pontos do sinal original
            ctx.fillStyle = '#6c9ce8';
            for (let i = 0; i < N; i++) {
                ctx.beginPath();
                ctx.arc(getX(i), getY(originalSignal[i]), 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawFrame(step, M) {
            drawBase();

            // 1. Desenhar janela destacada (Retângulo amarelo)
            if (step >= M - 1) {
                let startX = getX(step - M + 1);
                let endX = getX(step);
                
                ctx.fillStyle = 'rgba(255, 193, 7, 0.3)'; // Amarelo translúcido
                // Retângulo cobre da base ao topo do gráfico
                ctx.fillRect(startX, margin, endX - startX, height);
                
                // Borda da janela
                ctx.strokeStyle = '#ffb300';
                ctx.lineWidth = 1;
                ctx.strokeRect(startX, margin, endX - startX, height);

                // Destacar os pontos dentro da janela
                ctx.fillStyle = '#ff6b6b';
                for(let k = step - M + 1; k <= step; k++) {
                    ctx.beginPath();
                    ctx.arc(getX(k), getY(originalSignal[k]), 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 2. Desenhar o sinal filtrado acumulado
            ctx.beginPath();
            let firstPoint = true;
            for (let i = 0; i <= step; i++) {
                if (filteredSignal[i] !== null) {
                    let x = getX(i);
                    let y = getY(filteredSignal[i]);
                    if (firstPoint) {
                        ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            }
            ctx.strokeStyle = '#ff0000'; // Vermelho
            ctx.lineWidth = 3;
            ctx.stroke();

            // 3. Desenhar o ponto atual em vermelho forte
            if (filteredSignal[step] !== null) {
                ctx.beginPath();
                ctx.arc(getX(step), getY(filteredSignal[step]), 5, 0, Math.PI * 2);
                ctx.fillStyle = '#ff0000';
                ctx.fill();
            }
        }

        function animate() {
            const M = parseInt(mInput.value);
            
            // Calculando a média da janela atual
            let sum = 0;
            for (let i = currentStep - M + 1; i <= currentStep; i++) {
                sum += originalSignal[i];
            }
            let avg = sum / M;
            filteredSignal[currentStep] = avg;

            drawFrame(currentStep, M);

            currentStep++;

            if (currentStep < N) {
                let delay = parseInt(speedInput.max) - parseInt(speedInput.value) + 10;
                animationTimer = setTimeout(animate, delay);
            } else {
                isAnimating = false;
                btnStart.disabled = false;
                mInput.disabled = false;
                btnStart.innerText = "Aplicar Média Móvel";
            }
        }

        function startSimulation() {
            if (isAnimating) return;
            
            const M = parseInt(mInput.value);
            filteredSignal = new Array(N).fill(null);
            
            // O primeiro ponto calculável é onde temos pelo menos M amostras (M-1 em índice zero-based)
            currentStep = M - 1; 
            isAnimating = true;
            
            btnStart.disabled = true;
            mInput.disabled = true;
            btnStart.innerText = "Calculando...";
            
            animate();
        }

        function resetSimulation() {
            clearTimeout(animationTimer);
            isAnimating = false;
            btnStart.disabled = false;
            mInput.disabled = false;
            btnStart.innerText = "Aplicar Média Móvel";
            
            generateData();
            drawBase();
        }

        // Listeners
        btnStart.addEventListener('click', startSimulation);
        btnReset.addEventListener('click', resetSimulation);
        mInput.addEventListener('change', () => {
            if(!isAnimating) {
                filteredSignal = new Array(N).fill(null);
                drawBase();
            }
        });

        // Inicialização
        resetSimulation();
    </script>
</body>
</html>