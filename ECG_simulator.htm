<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador Vetorial de ECG</title>
  <style>
    :root {
      --bg0: #f8f9fa; --bg1: #e9ecef;
      --text: #212529; --muted: #6c757d;
      --accent: #0d6efd; --danger: #dc3545;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; min-height: 100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--text); background: linear-gradient(180deg, var(--bg0) 0%, var(--bg1) 100%);
      overflow-x: hidden;
    }
    .wrap { max-width: 1250px; margin: 0 auto; padding: 22px; }
    header { margin-bottom: 16px; }
    h1 { font-size: 22px; margin: 0 0 4px 0; font-weight: 700; color: #1a1d20; }
    .subtitle { font-size: 13px; color: var(--muted); max-width: 100ch; line-height: 1.4; }
    .grid { display: grid; grid-template-columns: 1fr 1.15fr; gap: 20px; }
    
    .card { background: #fff; border: 1px solid #ced4da; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.05); overflow: hidden; }
    .cardHead { padding: 12px 18px; display: flex; align-items: center; gap: 8px; border-bottom: 1px solid #ced4da; background: #f8f9fa; font-weight: 700; font-size: 14px; letter-spacing: 0.3px; }
    .dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }
    .cardBody { padding: 16px; }
    
    .controls { display: flex; gap: 12px; padding: 12px; border-radius: 10px; background: #f1f3f5; border: 1px solid #e9ecef; margin-bottom: 16px; flex-wrap: wrap; align-items: flex-end; }
    .ctrl-group { flex: 1; min-width: 140px; }
    .k { font-size: 11px; font-weight: 700; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
    .v { font-variant-numeric: tabular-nums; font-size: 14px; color: var(--accent); }
    
    input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer; height: 6px; }
    button { appearance: none; border: 1px solid var(--accent); background: #fff; color: var(--accent); border-radius: 6px; padding: 8px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: 0.15s; height: 36px; }
    button:hover { background: var(--accent); color: #fff; }
    button.outline { border-color: var(--muted); color: var(--muted); }
    button.outline:hover { border-color: var(--text); color: var(--text); background: #e9ecef; }
    
    .canvasWrap { border-radius: 8px; overflow: hidden; border: 1px solid #ced4da; touch-action: none; position: relative; background: #fff; box-shadow: inset 0 2px 6px rgba(0,0,0,0.04); }
    canvas { display: block; width: 100%; height: auto; }
    @media (max-width: 980px){ .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>

<div class="wrap">
  <header>
    <h1>Simulador Vetorial de ECG <span style="font-weight:400; color:var(--muted); font-size:16px;">| Anatomia Realista</span></h1>
  </header>

  <div class="grid">
    <section class="card">
      <div class="cardHead" style="color:var(--accent);"><span class="dot" style="background:var(--accent);"></span> Eixo Anatômico e Vectocardiograma</div>
      <div class="cardBody">
        <div class="controls">
          <div class="ctrl-group"><div class="k">Freq: <span class="v" id="hrVal">60</span> bpm</div><input id="hr" type="range" min="35" max="150" value="60" /></div>
          <div class="ctrl-group"><div class="k">Velocidade: <span class="v" id="spdVal">0.25</span>x</div><input id="speed" type="range" min="0.05" max="1.00" step="0.05" value="0.25" /></div>
          <button id="btnReset" class="outline">Resetar Polos</button>
        </div>
        <div class="canvasWrap"><canvas id="torso" width="980" height="740"></canvas></div>
      </div>
    </section>

    <section class="card">
      <div class="cardHead" style="color:var(--danger);"><span class="dot" style="background:var(--danger);"></span> Papel Milimetrado (Traçado Resultante)</div>
      <div class="cardBody">
        <div class="controls">
          <div class="ctrl-group"><div class="k">Ganho (Amplitude): <span class="v" id="gainTxt">1.0</span>x</div><input id="gain" type="range" min="0.5" max="3" step="0.1" value="1.0" /></div>
          <button id="btnClear" class="outline">Limpar Traçado</button>
        </div>
        <div class="canvasWrap" style="border-color: #fca5a5;"><canvas id="scope" width="1100" height="740"></canvas></div>
      </div>
    </section>
  </div>
</div>

<script>
(() => {
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  function gauss(u, mu, sig){ return Math.exp(-0.5*Math.pow((u-mu)/sig, 2)); }
  function norm2(x,y){ const n = Math.hypot(x,y)||1; return {x:x/n, y:y/n}; }

  const cTorso = document.getElementById("torso"), cScope = document.getElementById("scope");
  const tctx = cTorso.getContext("2d"), sctx = cScope.getContext("2d", {alpha:false});

  function fitCanvas(canvas){
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.floor(rect.width * dpr), h = Math.floor(rect.height * dpr);
    if(canvas.width !== w || canvas.height !== h){ canvas.width = w; canvas.height = h; }
    return {w,h,dpr};
  }

  const scope = { fs: 1000, seconds: 3.0, N: 0, y: null, write: 0 };
  function resetScope(){
    scope.N = Math.floor(scope.fs * scope.seconds);
    scope.y = new Float32Array(scope.N);
    scope.write = 0;
  }

  const electrodes = {
    NEG: {x: 0.30, y: 0.32, r: 0.028, bg: "#0d6efd", fg: "#fff", label: "−", shadow: "rgba(13, 110, 253, 0.4)"},
    POS: {x: 0.55, y: 0.82, r: 0.028, bg: "#dc3545", fg: "#fff", label: "+", shadow: "rgba(220, 53, 69, 0.4)"}
  };
  function setDefaultElectrodes(){ electrodes.NEG.x=0.30; electrodes.NEG.y=0.32; electrodes.POS.x=0.55; electrodes.POS.y=0.82; }

  let HR = 60, gain = 1.0, speed = 0.25, simTime = 0;
  let currentEx = 0, currentEy = 0;

  // Vetores Anatômicos (Loops)
  const dirP = norm2( 0.7,  0.9);
  const dirQ = norm2(-0.6, -0.3);
  const dirR = norm2( 0.4,  1.0);
  const dirS = norm2(-0.3, -0.8);
  const dirT = norm2( 0.5,  0.7);

  function heartVector(u){
    const p_amp = 0.18 * gauss(u, 0.14, 0.022); 
    const q_amp = 0.22 * gauss(u, 0.295, 0.011);
    const r_amp = 1.55 * gauss(u, 0.320, 0.013);
    const s_amp = 0.42 * gauss(u, 0.345, 0.016);
    const t_amp = 0.38 * gauss(u, 0.58, 0.060);

    const Ex = p_amp*dirP.x + q_amp*dirQ.x + r_amp*dirR.x + s_amp*dirS.x + t_amp*dirT.x;
    const Ey = p_amp*dirP.y + q_amp*dirQ.y + r_amp*dirR.y + s_amp*dirS.y + t_amp*dirT.y;
    currentEx = Ex; currentEy = Ey;
    return {Ex, Ey};
  }

  function getAxisData(w, h){
    const a = electrodes.NEG, b = electrodes.POS;
    const dx = (b.x - a.x)*w, dy = (b.y - a.y)*h;
    const n = Math.hypot(dx, dy) || 1;
    return { ux: dx/n, uy: dy/n, n };
  }

  function drawArrow(ctx, fromX, fromY, toX, toY, color) {
    const headlen = 14;
    const angle = Math.atan2(toY - fromY, toX - fromX);
    ctx.save();
    ctx.strokeStyle = color; ctx.lineWidth = 3.5; ctx.lineCap = "round";
    ctx.shadowColor = "rgba(25, 135, 84, 0.3)"; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 7), toY - headlen * Math.sin(angle - Math.PI / 7));
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 7), toY - headlen * Math.sin(angle + Math.PI / 7));
    ctx.closePath();
    ctx.fillStyle = color; ctx.fill();
    ctx.restore();
  }

  // --- NOVA FUNÇÃO DE DESENHO DO TORSO REALISTA ---
  function drawTorso(){
    const {w,h} = fitCanvas(cTorso); const ctx = tctx;
    ctx.clearRect(0,0,w,h);

    // Fundo gradiente suave
    const bgGrad = ctx.createLinearGradient(0,0,0,h);
    bgGrad.addColorStop(0, "#f8f9fa"); bgGrad.addColorStop(1, "#e9ecef");
    ctx.fillStyle = bgGrad; ctx.fillRect(0,0,w,h);

    const cx = w*0.50, cy = h*0.50, Tw = w*0.75, Th = h*0.85;
    const yTop = cy - Th*0.48, yBot = cy + Th*0.48;

    // Silhueta Humana Realista
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(cx - Tw*0.14, yTop); // Pescoço Esq
    // Ombro e Braço Esq
    ctx.bezierCurveTo(cx - Tw*0.28, yTop + Th*0.01, cx - Tw*0.42, yTop + Th*0.10, cx - Tw*0.48, yTop + Th*0.22); 
    ctx.bezierCurveTo(cx - Tw*0.50, yTop + Th*0.30, cx - Tw*0.48, yTop + Th*0.45, cx - Tw*0.44, yBot - Th*0.15);
    // Cintura e Quadril Esq
    ctx.bezierCurveTo(cx - Tw*0.40, yBot - Th*0.05, cx - Tw*0.35, yBot, cx, yBot); 
    // Cintura e Quadril Dir
    ctx.bezierCurveTo(cx + Tw*0.35, yBot, cx + Tw*0.40, yBot - Th*0.05, cx + Tw*0.44, yBot - Th*0.15);
    // Ombro e Braço Dir
    ctx.bezierCurveTo(cx + Tw*0.48, yTop + Th*0.45, cx + Tw*0.50, yTop + Th*0.30, cx + Tw*0.48, yTop + Th*0.22);
    ctx.bezierCurveTo(cx + Tw*0.42, yTop + Th*0.10, cx + Tw*0.28, yTop + Th*0.01, cx + Tw*0.14, yTop); // Pescoço Dir
    ctx.closePath();

    // Preenchimento e Contorno do Torso
    const torsoGrad = ctx.createLinearGradient(cx, yTop, cx, yBot);
    torsoGrad.addColorStop(0, "#e2e6ea"); torsoGrad.addColorStop(1, "#d1d9e1");
    ctx.fillStyle = torsoGrad; ctx.fill();
    ctx.strokeStyle = "#caced6"; ctx.lineWidth = 2; ctx.stroke();
    
    // Detalhes Anatômicos Sutis (Clavículas e Peitoral)
    ctx.globalAlpha = 0.2; ctx.strokeStyle = "#6c757d"; ctx.lineWidth = 1.5;
    ctx.beginPath(); // Clavículas
    ctx.moveTo(cx - Tw*0.12, yTop + Th*0.04); ctx.quadraticCurveTo(cx, yTop + Th*0.07, cx + Tw*0.12, yTop + Th*0.04);
    ctx.stroke();
    ctx.beginPath(); // Linha inferior do peitoral
    ctx.moveTo(cx - Tw*0.22, yTop + Th*0.38); ctx.bezierCurveTo(cx, yTop + Th*0.45, cx, yTop + Th*0.45, cx + Tw*0.22, yTop + Th*0.38);
    ctx.stroke();
    ctx.globalAlpha = 1.0;
    ctx.restore();

    // Coração (Posição Anatômica)
    const hx = cx + Tw*0.04, hy = yTop + Th*0.35;
    ctx.fillStyle = "#ffccd5"; ctx.shadowColor="rgba(220, 53, 69, 0.15)"; ctx.shadowBlur=15;
    ctx.beginPath(); ctx.ellipse(hx, hy, w*0.065, w*0.055, Math.PI/6, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur=0;

    // Linha de Derivação
    const p1 = electrodes.NEG, p2 = electrodes.POS;
    ctx.strokeStyle = "#aeb5bc"; ctx.setLineDash([5, 7]); ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(p1.x*w, p1.y*h); ctx.lineTo(p2.x*w, p2.y*h); ctx.stroke(); ctx.setLineDash([]);

    const { ux, uy } = getAxisData(w, h);
    
    // Vetor e Projeção
    const magnitude = Math.hypot(currentEx, currentEy);
    if(magnitude > 0.02) {
      const vectorScale = w * 0.16;
      const vx = hx + currentEx * vectorScale, vy = hy + currentEy * vectorScale;
      const projScalar = (currentEx * vectorScale) * ux + (currentEy * vectorScale) * uy;
      const projX = hx + projScalar * ux, projY = hy + projScalar * uy;

      // Sombra (Projeção Ortogonal)
      ctx.strokeStyle = "rgba(220, 53, 69, 0.25)"; ctx.setLineDash([2, 3]); ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(vx, vy); ctx.lineTo(projX, projY); ctx.stroke(); ctx.setLineDash([]);

      // Resultado no Eixo (Linha Grossa Vermelha)
      ctx.strokeStyle = "#dc3545"; ctx.lineWidth = 5; ctx.lineCap = "round";
      ctx.shadowColor = "rgba(220, 53, 69, 0.4)"; ctx.shadowBlur = 8;
      ctx.beginPath(); ctx.moveTo(hx, hy); ctx.lineTo(projX, projY); ctx.stroke(); ctx.shadowBlur=0;

      // Vetor Real (Seta Verde)
      drawArrow(ctx, hx, hy, vx, vy, "#198754");
    }

    // Eletrodos
    ["NEG","POS"].forEach(k => {
      const e = electrodes[k], x = e.x*w, y = e.y*h, r = e.r*Math.min(w,h);
      ctx.save();
      ctx.shadowColor = e.shadow; ctx.shadowBlur = 12;
      ctx.fillStyle = e.bg; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.lineWidth = 3; ctx.strokeStyle = "#ffffff"; ctx.stroke();
      ctx.fillStyle = e.fg; ctx.font = `700 ${Math.max(15, w*0.018)}px sans-serif`;
      ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(e.label, x, y+1);
      ctx.restore();
    });
  }
  // --------------------------------------------------

  function drawScope(){
    const {w,h} = fitCanvas(cScope); const ctx = sctx;
    ctx.fillStyle = "#fffcfc"; ctx.fillRect(0,0,w,h);
    const pxPerMm = w / (scope.seconds * 25); 
    ctx.lineWidth = 0.5; ctx.strokeStyle = "rgba(255, 180, 180, 0.5)"; ctx.beginPath();
    for(let i=0; i<=w; i+=pxPerMm){ ctx.moveTo(i, 0); ctx.lineTo(i, h); }
    for(let j=Math.floor(h/2)+0.5; j<h; j+=pxPerMm){ ctx.moveTo(0, j); ctx.lineTo(w, j); ctx.moveTo(0, h-(j)); ctx.lineTo(w, h-(j)); } ctx.stroke();
    ctx.lineWidth = 1.0; ctx.strokeStyle = "rgba(255, 150, 150, 0.7)"; ctx.beginPath();
    for(let i=0; i<=w; i+=pxPerMm*5){ ctx.moveTo(i, 0); ctx.lineTo(i, h); }
    for(let j=Math.floor(h/2)+0.5; j<h; j+=pxPerMm*5){ ctx.moveTo(0, j); ctx.lineTo(w, j); ctx.moveTo(0, h-(j)); ctx.lineTo(w, h-(j)); } ctx.stroke();

    ctx.lineWidth = 2.2; ctx.lineJoin = "round"; ctx.strokeStyle = "#111827";
    ctx.beginPath();
    for(let px=0; px<w; px++){
      const t = px/(w-1), s = t*(scope.N-1), i0 = Math.floor(s), frac = s - i0;
      const yv = scope.y[(scope.write+i0)%scope.N]*(1-frac) + scope.y[(scope.write+Math.min(i0+1,scope.N-1))%scope.N]*frac;
      const plotY = (Math.floor(h/2)+0.5) - (yv * (10 * pxPerMm) * gain); 
      if(px===0) ctx.moveTo(px,plotY); else ctx.lineTo(px,plotY);
    } ctx.stroke();
  }

  let dragKey = null;
  cTorso.addEventListener("pointerdown", (ev)=>{
    const r = cTorso.getBoundingClientRect(), mx = (ev.clientX - r.left)*(cTorso.width/r.width), my = (ev.clientY - r.top)*(cTorso.height/r.height);
    for(const key of ["NEG","POS"]){
      const e = electrodes[key], x = e.x*cTorso.width, y = e.y*cTorso.height;
      if(Math.hypot(mx-x,my-y) <= e.r*Math.min(cTorso.width,cTorso.height)*4) { dragKey = key; cTorso.setPointerCapture(ev.pointerId); break; }
    }
  });
  cTorso.addEventListener("pointermove", (ev)=>{
    if(!dragKey) return;
    const r = cTorso.getBoundingClientRect(), mx = (ev.clientX - r.left)*(cTorso.width/r.width), my = (ev.clientY - r.top)*(cTorso.height/r.height);
    electrodes[dragKey].x = clamp(mx / cTorso.width, 0.05, 0.95); electrodes[dragKey].y = clamp(my / cTorso.height, 0.05, 0.95);
  });
  cTorso.addEventListener("pointerup", ()=>{ dragKey = null; });

  let lastFrame = performance.now();
  function updateUI(){
    document.getElementById("hrVal").textContent = Math.round(HR);
    document.getElementById("spdVal").textContent = speed.toFixed(2);
    document.getElementById("gainTxt").textContent = gain.toFixed(1);
  }
  function tick(tNow){
    const dt = Math.max(0.001, (tNow - lastFrame)/1000) * speed;
    simTime += dt;
    for(let i=0, steps=Math.max(1, Math.floor(scope.fs * dt)); i<steps; i++){
      const hv = heartVector((simTime % (60/HR)) / (60/HR));
      const { ux, uy } = getAxisData(1, 1); 
      scope.y[scope.write] = hv.Ex * ux + hv.Ey * uy; 
      scope.write = (scope.write + 1) % scope.N;
    }
    drawTorso(); drawScope();
    lastFrame = tNow; requestAnimationFrame(tick);
  }

  document.getElementById("hr").addEventListener("input", (e)=>{ HR = parseFloat(e.target.value); updateUI(); });
  document.getElementById("speed").addEventListener("input", (e)=>{ speed = parseFloat(e.target.value); updateUI(); });
  document.getElementById("gain").addEventListener("input", (e)=>{ gain = parseFloat(e.target.value); updateUI(); });
  document.getElementById("btnClear").addEventListener("click", resetScope);
  document.getElementById("btnReset").addEventListener("click", setDefaultElectrodes);

  resetScope(); setDefaultElectrodes(); updateUI(); requestAnimationFrame(tick);
})();
</script>
</body>
</html>